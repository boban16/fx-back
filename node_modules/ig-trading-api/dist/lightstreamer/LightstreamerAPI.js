"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LightstreamerAPI = void 0;
const lightstreamer_client_node_1 = require("lightstreamer-client-node");
const luxon_1 = require("luxon");
const interfaces_1 = require("./interfaces");
class LightstreamerAPI {
    constructor(auth) {
        this.auth = auth;
    }
    createLightStream() {
        if (!this.lightstream) {
            this.lightstream = new lightstreamer_client_node_1.LightstreamerClient(this.auth.lightstreamerEndpoint, '');
            this.lightstream.connectionDetails.setUser(this.auth.accountId);
            this.lightstream.connectionDetails.setPassword(`CST-${this.auth.clientSessionToken}|XST-${this.auth.securityToken}`);
        }
        return this.lightstream;
    }
    subscribeCandles(epicList, resolution, onCandleUpdate) {
        const lightstream = this.createLightStream();
        const fields = [
            interfaces_1.ChartFields.BID_HIGH,
            interfaces_1.ChartFields.BID_LOW,
            interfaces_1.ChartFields.BID_CLOSE,
            interfaces_1.ChartFields.BID_OPEN,
            interfaces_1.ChartFields.OFR_CLOSE,
            interfaces_1.ChartFields.OFR_HIGH,
            interfaces_1.ChartFields.OFR_LOW,
            interfaces_1.ChartFields.OFR_OPEN,
            interfaces_1.ChartFields.UTM,
            interfaces_1.ChartFields.LTP_CLOSE,
            interfaces_1.ChartFields.LTP_HIGH,
            interfaces_1.ChartFields.LTP_LOW,
            interfaces_1.ChartFields.LTP_OPEN,
            interfaces_1.ChartFields.LTV,
        ];
        if (this.candleSubscription) {
            lightstream.unsubscribe(this.candleSubscription);
        }
        const epics = epicList.map(x => `CHART:${x}:${resolution}`);
        this.candleSubscription = new lightstreamer_client_node_1.Subscription('MERGE', epics, fields);
        this.candleSubscription.addListener({
            onItemUpdate: (item) => {
                const dt = luxon_1.DateTime.fromMillis(parseInt(item.getValue(interfaces_1.ChartFields.UTM)));
                const epic = item.getItemName().split(':')[1];
                const candle = {
                    closePrice: {
                        ask: parseFloat(item.getValue(interfaces_1.ChartFields.OFR_CLOSE)),
                        bid: parseFloat(item.getValue(interfaces_1.ChartFields.BID_CLOSE)),
                        lastTraded: parseFloat(item.getValue(interfaces_1.ChartFields.LTP_CLOSE)),
                    },
                    highPrice: {
                        ask: parseFloat(item.getValue(interfaces_1.ChartFields.OFR_HIGH)),
                        bid: parseFloat(item.getValue(interfaces_1.ChartFields.BID_HIGH)),
                        lastTraded: parseFloat(item.getValue(interfaces_1.ChartFields.LTP_HIGH)),
                    },
                    lastTradedVolume: parseInt(item.getValue(interfaces_1.ChartFields.LTV)),
                    lowPrice: {
                        ask: parseFloat(item.getValue(interfaces_1.ChartFields.OFR_LOW)),
                        bid: parseFloat(item.getValue(interfaces_1.ChartFields.BID_LOW)),
                        lastTraded: parseFloat(item.getValue(interfaces_1.ChartFields.LTP_LOW)),
                    },
                    openPrice: {
                        ask: parseFloat(item.getValue(interfaces_1.ChartFields.OFR_OPEN)),
                        bid: parseFloat(item.getValue(interfaces_1.ChartFields.BID_OPEN)),
                        lastTraded: parseFloat(item.getValue(interfaces_1.ChartFields.LTP_OPEN)),
                    },
                    snapshotTime: dt.toFormat('yyyy/LL/dd HH:mm:ss'),
                    snapshotTimeUTC: dt.toFormat("yyyy-LL-dd'T'HH:mm:ss"),
                };
                onCandleUpdate(epic, candle);
            },
        });
        lightstream.connect();
        lightstream.subscribe(this.candleSubscription);
        return lightstream;
    }
}
exports.LightstreamerAPI = LightstreamerAPI;
//# sourceMappingURL=LightstreamerAPI.js.map